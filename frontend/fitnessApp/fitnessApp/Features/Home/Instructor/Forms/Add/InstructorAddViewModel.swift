//
//  InstructorAddViewModel.swift
//  fitnessApp
//
//  Created by Karolína Droscová on 07.12.2024.
//

import Foundation

protocol InstructorAddViewFlowDelegate: NSObject {
    func onLoadError()
    func onBackPressed()
    func onSaveSuccess()
    func onSaveFailure(message: String)
}

protocol InstructorAddViewModeling: BaseClass, ObservableObject {
    var name: String { get set }
    var surname: String { get set }
    var birthdate: Date? { get set }
    var specializations: [SelectableItem<ClassType>] { get set }
    var isLoading: Bool { get set }
    func onAppear()
    func onBackPressed()
    func onSavePressed()
}

final class InstructorAddViewModel: BaseClass, InstructorAddViewModeling {
    typealias Dependencies = HasLoggerService & HasInstructorManager & HasClassTypeManager

    private let logger: LoggerServicing
    private let instructorManager: InstructorManaging
    private let classTypeManager: ClassTypeManaging
    private weak var delegate: InstructorAddViewFlowDelegate?

    @Published var name: String = ""
    @Published var surname: String = ""
    @Published var birthdate: Date? = nil
    @Published var specializations: [SelectableItem<ClassType>] = []
    @Published var isLoading: Bool = true

    init(dependencies: Dependencies, delegate: InstructorAddViewFlowDelegate? = nil) {
        self.logger = dependencies.logger
        self.instructorManager = dependencies.instructorManager
        self.classTypeManager = dependencies.classTypeManager
        self.delegate = delegate
    }

    func onAppear() {
        Task { @MainActor [weak self] in
            guard let self = self else { return }
            self.isLoading = true
            defer { self.isLoading = false }

            do {
                try await self.fetchSpecializations()
            } catch {
                self.delegate?.onLoadError()
            }
        }
    }

    func onBackPressed() {
        delegate?.onBackPressed()
    }

    func onSavePressed() {
        Task { @MainActor [weak self] in
            guard let self = self else { return }

            guard !self.name.isEmpty, !self.surname.isEmpty, let birthdate = self.birthdate else {
                self.delegate?.onSaveFailure(message: "All fields must be filled in")
                return
            }

            do {
                let selectedSpecializationIds = self.specializations.filter { $0.isSelected }.map { $0.item.classTypeId! }

                let newInstructor = Instructor(
                    instructorId: nil, // ID will be generated by the backend
                    name: self.name,
                    surname: self.surname,
                    birthDate: birthdate,
                    specializations: selectedSpecializationIds
                )

                try await self.instructorManager.createInstructor(newInstructor)
                self.delegate?.onSaveSuccess()
            } catch let baseError as BaseError {
                delegate?.onSaveFailure(message: baseError.message)
            } catch {
                delegate?.onSaveFailure(message: error.localizedDescription)
            }
        }
    }

    // MARK: - Private Helpers

    private func fetchSpecializations() async throws {
        try await classTypeManager.fetchClassTypes()
        let fetchedSpecializations = classTypeManager.allClassTypes.map {
            SelectableItem(item: $0, itemDescription: $0.name)
        }
        DispatchQueue.main.async { [weak self] in
            self?.specializations = fetchedSpecializations
        }
    }
}
