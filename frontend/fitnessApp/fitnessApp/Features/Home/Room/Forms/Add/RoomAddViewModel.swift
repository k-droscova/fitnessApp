//
//  RoomAddViewModel.swift
//  fitnessApp
//
//  Created by Karolína Droscová on 07.12.2024.
//

import Foundation

protocol RoomAddViewFlowDelegate: NSObject {
    func onLoadError()
    func onBackPressed()
    func onSaveSuccess()
    func onSaveFailure(message: String)
}

protocol RoomAddViewModeling: BaseClass, ObservableObject {
    var maxCapacity: Int { get set }
    var classTypes: [SelectableItem<ClassType>] { get set }
    var isLoading: Bool { get set }
    func onAppear()
    func onBackPressed()
    func onSavePressed()
}

final class RoomAddViewModel: BaseClass, RoomAddViewModeling {
    typealias Dependencies = HasLoggerService & HasRoomManager & HasClassTypeManager

    private let logger: LoggerServicing
    private let roomManager: RoomManaging
    private let classTypeManager: ClassTypeManaging
    private weak var delegate: RoomAddViewFlowDelegate?

    @Published var maxCapacity: Int = 0
    @Published var classTypes: [SelectableItem<ClassType>] = []
    @Published var isLoading: Bool = true

    init(dependencies: Dependencies, delegate: RoomAddViewFlowDelegate? = nil) {
        self.logger = dependencies.logger
        self.roomManager = dependencies.roomManager
        self.classTypeManager = dependencies.classTypeManager
        self.delegate = delegate
    }

    func onAppear() {
        Task { @MainActor [weak self] in
            guard let self = self else { return }
            self.isLoading = true
            defer { self.isLoading = false }

            do {
                try await self.fetchClassTypes()
            } catch {
                self.delegate?.onLoadError()
            }
        }
    }

    func onBackPressed() {
        delegate?.onBackPressed()
    }

    func onSavePressed() {
        Task { @MainActor [weak self] in
            guard let self = self else { return }

            guard maxCapacity > 0 else {
                self.delegate?.onSaveFailure(message: "Capacity must be a valid positive number")
                return
            }
            
            guard self.classTypes.isNotEmpty else {
                self.delegate?.onSaveFailure(message: "Please select at least one class type")
                return
            }

            do {
                let selectedClassTypeIds = self.classTypes.filter { $0.isSelected }.map { $0.item.classTypeId! }

                let newRoom = Room(
                    roomId: nil, // ID will be generated by the backend
                    maxCapacity: maxCapacity,
                    classes: [], 
                    classTypes: selectedClassTypeIds
                )

                try await self.roomManager.createRoom(newRoom)
                self.delegate?.onSaveSuccess()
            } catch let baseError as BaseError {
                delegate?.onSaveFailure(message: baseError.message)
            } catch {
                delegate?.onSaveFailure(message: error.localizedDescription)
            }
        }
    }

    // MARK: - Private Helpers

    private func fetchClassTypes() async throws {
        try await classTypeManager.fetchClassTypes()
        let fetchedClassTypes = classTypeManager.allClassTypes.map {
            SelectableItem(item: $0, itemDescription: $0.name)
        }
        DispatchQueue.main.async { [weak self] in
            self?.classTypes = fetchedClassTypes
        }
    }
}
