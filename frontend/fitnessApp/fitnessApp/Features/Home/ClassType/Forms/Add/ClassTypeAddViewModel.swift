//
//  ClassTypeAddViewModel.swift
//  fitnessApp
//
//  Created by Karolína Droscová on 05.12.2024.
//

import Foundation

protocol ClassTypeAddViewFlowDelegate: NSObject {
    func onLoadError()
    func onBackPressed()
    func onSaveSuccess()
    func onSaveFailure(message: String)
}

protocol ClassTypeAddViewModeling: BaseClass, ObservableObject {
    var classTypeName: String { get set }
    var instructors: [SelectableItem<Instructor>] { get set }
    var rooms: [SelectableItem<Room>] { get set }
    var isLoading: Bool { get set }
    func onAppear()
    func onBackPressed()
    func onSavePressed()
}

final class ClassTypeAddViewModel: BaseClass, ClassTypeAddViewModeling {
    typealias Dependencies = HasLoggerService & HasClassTypeManager & HasInstructorManager & HasRoomManager

    private let logger: LoggerServicing
    private let classTypeManager: ClassTypeManaging
    private let instructorManager: InstructorManaging
    private let roomManager: RoomManaging
    private weak var delegate: ClassTypeAddViewFlowDelegate?

    @Published var isLoading: Bool = true
    @Published var classTypeName: String = ""
    @Published var instructors: [SelectableItem<Instructor>] = []
    @Published var rooms: [SelectableItem<Room>] = []

    init(dependencies: Dependencies, delegate: ClassTypeAddViewFlowDelegate? = nil) {
        self.logger = dependencies.logger
        self.instructorManager = dependencies.instructorManager
        self.roomManager = dependencies.roomManager
        self.classTypeManager = dependencies.classTypeManager
        self.delegate = delegate
    }

    func onAppear() {
        Task { @MainActor [weak self] in
            guard let self = self else { return }
            self.isLoading = true
            defer { self.isLoading = false }

            do {
                try await self.fetchAllData()
            } catch {
                self.delegate?.onLoadError()
            }
        }
    }

    func onBackPressed() {
        delegate?.onBackPressed()
    }

    func onSavePressed() {
        Task { @MainActor [weak self] in
            guard let self = self else { return }

            guard !self.classTypeName.isEmpty else {
                self.delegate?.onSaveFailure(message: "Class name cannot be empty")
                return
            }

            do {
                let selectedInstructorIds = self.instructors.filter { $0.isSelected }.map { $0.item.instructorId! }
                let selectedRoomIds = self.rooms.filter { $0.isSelected }.map { $0.item.roomId! }

                let newClassType = ClassType(
                    classTypeId: nil, // ID will be generated by the backend
                    name: self.classTypeName,
                    instructors: selectedInstructorIds,
                    rooms: selectedRoomIds
                )

                try await self.classTypeManager.createClassType(newClassType)
                self.delegate?.onSaveSuccess()
            } catch let baseError as BaseError {
                delegate?.onSaveFailure(message: baseError.message)
            } catch {
                delegate?.onSaveFailure(message: error.localizedDescription)
            }
        }
    }

    // MARK: - Private Helpers

    private func fetchAllData() async throws {
        try await withThrowingTaskGroup(of: Void.self) { group in
            group.addTask { [weak self] in
                guard let self = self else { return }
                try await self.fetchInstructors()
            }
            group.addTask { [weak self] in
                guard let self = self else { return }
                try await self.fetchRooms()
            }
            try await group.waitForAll()
        }
    }

    private func fetchInstructors() async throws {
        try await instructorManager.fetchInstructors()
        let fetchedInstructors = instructorManager.allInstructors.map {
            SelectableItem(item: $0, itemDescription: "\($0.name) \($0.surname)")
        }
        DispatchQueue.main.async { [weak self] in
            self?.instructors = fetchedInstructors
        }
    }

    private func fetchRooms() async throws {
        try await roomManager.fetchRooms()
        let fetchedRooms = roomManager.allRooms.map {
            SelectableItem(item: $0, itemDescription: "Room \($0.roomId ?? 0)")
        }
        DispatchQueue.main.async { [weak self] in
            self?.rooms = fetchedRooms
        }
    }
}
